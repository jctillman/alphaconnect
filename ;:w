#
# Monte Carlo tree interface meant to 
# work with the Abstract Game interface.
# It assumes that all games will eventually 
# end if played randomly, at the moment, so 
# is better with games like Go or Connect 4
# or TicTacToe than games like Chess
# 
# It is NOT meant to make moves, but to take
# an abstract game, in a particular state, and to 
# return a probability distribution over the moves
# indicating the probability different moves should
# be made
#

import random
from utils import softmax, random_simulation, uct_factory, uniform_policy
from math import sqrt, log

def MCTS(abstract_game_instance,
        iteration_number = 1000,
        c = 1,
        policy_estimator = uniform_policy):

        # Get initial games states, and functions
        # to be used throughout
        inst = abstract_game_instance
        uct = uct_factory(c)

        # Intialize tree of game nodes...
        nodes = {}
        root_player = inst.move_turn()
        root_node = {
            'game': inst,
            'hash': inst.hash(),
            'prob': None,
            'visits': 1.0,
            'victories': 0.0,
            'parent_hash': None,
        }
        nodes[root_node['hash']] = root_node 

        # Function which, given a hash and a number
        # of victories, climbs the nodes corresponding
        # to that hash, until it reaches the root node
        def propogate_up_from(hsh, vict):
                climb_node = nodes[hsh]
                while (climb_node['parent_hash'] is not None):
                    climb_node['visits'] = climb_node['visits'] + 1
                    climb_node['victories'] = climb_node['victories'] + vict
                    climb_node = nodes[climb_node['parent_hash']]
      
        # Actually perform MCTS iteration from root_node
        # for iteration_number_times 
        for n in range(iteration_number):
            
            current_node = root_node
            not_hit_new_node = True

            # Rules for expansion:
            # 1. Keep going down until you
            #    hit a node that you haven't
            #    hit before.
            # 2. Select nodes that you choose
            #    EITHER randomly if you don't
            #    have complete information
            #    about them and their sibling
            #    nodes, OR according to UCT
            #    if all siblings have been 
            #    selected before (and thus
            #    there are statistics)
            while not_hit_new_node:

                cur_game = current_node['game']
                possible_moves = cur_game.move_list()
                possible_states = [ cur_game.move_immutable(x) for x in possible_moves ]

                presences = [ x.hash() in nodes for x in possible_states ]
                stats_for_all = all(presences)
                stats_for_some = any(presences)

                # Randomly select, if we haven't gotten 
                # all of the elements enough to have stats, otherwise
                # select by UCB.  I think this is where we inert some 
                # specification otherwise. 
                if stats_for_all:
                    child_nodes = [ nodes[hsh] for hsh in possible_states ]
                    child_iter = range(len(child_nodes))
                    child_values = [ uct(current_node, child_nodes[x] ) for x in child_iter ]
                    highest_value = max(child_values)
                    highest_value_index = child_values.index(highest_value)
                    current_node = child_nodes[highest_value_index]
                    not_hit_new_node = True
                else:
                    next_state = random.choice(possible_states)
                    next_state_hash = next_state.hash()
                    
                    if next_state_hash in nodes:
                        current_node = nodes[next_state_hash]
                        parent_nodes_exists = True
                    else:
                        not_hit_new_node = False

            print "!"
            node_game = current_node['game']
            poss_moves = node_game.move_list()

            if len(poss_moves) == 0:
                vict = random_simulation(node_game, root_player)
                propogate_up_from(current_node['hash'], vict)
            else:
                poss_move_probs = policy_estimator(node_game)
                child_hashes = []
                for idx, n in enumerate(poss_moves):
                    new_game = node_game.move_immutable(n)
                    new_hash = new_game.hash()
                    new_victories = random_simulation(new_game, root_player)
                    child_hashes.append(new_hash)
                    nodes[new_hash] = {
                        'game': new_game,
                        'hash': new_hash,
                        'prob': poss_move_probs[idx],
                        'visits': 0,
                        'victories': 0,
                        'expanded': False,
                        'child_hashes': None,
                        'parent_hash': current_node['hash'],
                    }
                propogate_up_from(new_hash, new_victories)
                current_node['child_hashes'] = child_hashes
                current_node['expanded'] = True

        print root_node

        root_children = [ nodes[hsh] for hsh in root_node['child_hashes'] ]
        print [ x['victories'] for x in root_children ]
        print [ x['visits'] for x in root_children ]
        return softmax([1,2,3]) 



